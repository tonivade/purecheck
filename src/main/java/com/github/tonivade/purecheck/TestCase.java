/*
 * Copyright (c) 2020, Antonio Gabriel Mu√±oz Conejo <antoniogmc at gmail dot com>
 * Distributed under the terms of the MIT License
 */
package com.github.tonivade.purecheck;

import static com.github.tonivade.purecheck.TestResult.error;
import static com.github.tonivade.purecheck.TestResult.failure;
import static com.github.tonivade.purecheck.TestResult.success;
import static com.github.tonivade.purefun.Precondition.checkNonEmpty;
import static com.github.tonivade.purefun.Precondition.checkNonNull;

import com.github.tonivade.purefun.Producer;
import com.github.tonivade.purefun.Validator;
import com.github.tonivade.purefun.monad.IO;
import com.github.tonivade.purefun.type.Either;
import com.github.tonivade.purefun.type.Try;
import com.github.tonivade.purefun.type.Validation.Result;

/**
 * It defines a test case, given an operation that eventually returns a value, then
 * it will apply some validations to check if the result is correct.
 * 
 * @author tonivade
 *
 * @param <E> type of error generated
 * @param <T> type under test
 */
public class TestCase<E, T> {
  
  /**
   * Name of the test case
   */
  private final String name;

  /**
   * Operation under test that returns a value {@code T}
   */
  private final IO<T> when;
  
  /**
   * Validation to apply to the result generated by operation
   */
  private final Either<Validator<Result<E>, Throwable>, Validator<Result<E>, T>> then;

  /**
   * It will throw {@code IllegalArgumentException} if parameters are null or if name is a empty string
   * 
   * @param name
   * @param when
   * @param then
   */
  private TestCase(String name, IO<T> when, Either<Validator<Result<E>, Throwable>, Validator<Result<E>, T>> then) {
    this.name = checkNonEmpty(name);
    this.when = checkNonNull(when);
    this.then = checkNonNull(then);
  }

  public IO<TestResult<E, T>> runIO() {
    return when.attempt().map(this::fold);
  }
  
  /**
   * It runs the operation and applies the validation
   * 
   * @return the validation result
   */
  public TestResult<E, T> run() {
    return runIO().unsafeRunSync();
  }

  private TestResult<E, T> fold(Try<T> result) {
    return then.fold(
            onError -> result.fold(
                    error -> onError.validate(error).fold(
                            r -> failure(name, error, r), t -> success(name, error)),
                    value -> error(name, value)),
            onSuccess -> result.fold(
                    error -> error(name, error),
                    value -> onSuccess.validate(value).fold(
                            r -> failure(name, value, r), t -> success(name, value))));
  }

  /**
   * It returns a builder like to create a new test case
   * @param <E> type of the result returned by the operation
   * @param <T> type of the error generated by the validator
   * @param name name of the test case
   * @return a new test case
   */
  public static <E, T> WhenStep<E, T> test(String name) {
    return when -> then -> new TestCase<>(name, when, then);
  }
  
  /**
   * It describe the step to define the operation to run by a test case
   *  
   * @param <E> type of the result returned by the operation
   * @param <T> type of the error generated by the validator
   */
  public interface WhenStep<E, T> {

    ThenStep<E, T> when(IO<T> operation);

    default ThenStep<E, T> when(Producer<T> operation) {
      return when(IO.task(operation));
    }
  }
  
  /**
   * It describe the step to define the validation to check by a test case
   * 
   * @param <E> type of the result returned by the operation
   * @param <T> type of the error generated by the validator
   */
  public interface ThenStep<E, T> {
    
    TestCase<E, T> then(Either<Validator<Result<E>, Throwable>, Validator<Result<E>, T>> validator);

    default TestCase<E, T> onSuccess(Validator<Result<E>, T> validator) {
      return then(Either.right(validator));
    }

    default TestCase<E, T> onFailure(Validator<Result<E>, Throwable> validator) {
      return then(Either.left(validator));
    }
    
    default TestCase<E, T> thenCheck(Validator<E, T> validator) {
      return onSuccess(validator.mapError(Result::of));
    }
    
    default TestCase<E, T> thenError(Validator<E, Throwable> validator) {
      return onFailure(validator.mapError(Result::of));
    }
  }
}
