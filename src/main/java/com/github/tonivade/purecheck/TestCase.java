/*
 * Copyright (c) 2020, Antonio Gabriel Mu√±oz Conejo <antoniogmc at gmail dot com>
 * Distributed under the terms of the MIT License
 */
package com.github.tonivade.purecheck;

import static com.github.tonivade.purecheck.TestResult.disabled;
import static com.github.tonivade.purecheck.TestResult.error;
import static com.github.tonivade.purecheck.TestResult.failure;
import static com.github.tonivade.purecheck.TestResult.success;
import static com.github.tonivade.purefun.Precondition.checkNonEmpty;
import static com.github.tonivade.purefun.Precondition.checkNonNull;

import java.time.Duration;

import com.github.tonivade.purefun.*;
import com.github.tonivade.purefun.monad.IO;
import com.github.tonivade.purefun.type.Either;
import com.github.tonivade.purefun.type.Try;
import com.github.tonivade.purefun.type.Validation.Result;

/**
 * It defines a test case, given an operation that eventually returns a value, then
 * it will apply some validations to check if the result is correct.
 * 
 * @author tonivade
 *
 * @param <E> type of error generated
 * @param <T> type of the result returned by the operation
 */
@HigherKind(sealed = true)
public interface TestCase<E, T> extends TestCaseOf<E, T> {

  String name();

  IO<TestResult<E, T>> runIO();

  TestCase<E, T> disable(String reason);

  TestCase<E, Tuple2<Duration, T>> timed();

  TestCase<E, T> retryOnFailure(int times);

  TestCase<E, T> retryOnError(int times);

  TestCase<E, T> repeat(int times);

  /**
   * It returns a builder to create a new test case
   *
   * @param name name of the test case
   * @return a new test case
   */
  static GivenStep test(String name) {
    return new GivenStep(name);
  }

  final class GivenStep {

    private final String name;

    private GivenStep(String name) {
      this.name = name;
    }

    public <T> WhenStep<T> given(T given) {
      return new WhenStep<>(name, given);
    }

    public <T> WhenStep<T> skip() {
      return given(null);
    }
  }

  final class WhenStep<T> {

    private final String name;

    private final T given;

    private WhenStep(String name, T given) {
      this.name = name;
      this.given = given;
    }

    public <R> ThenStep<T, R> run(Function1<T, IO<R>> when) {
      return new ThenStep<>(name, given, when);
    }

    public <R> ThenStep<T, R> when(Function1<T, R> when) {
      return run(when.liftTry().andThen(result -> result.fold(IO::raiseError, IO::pure)));
    }

    public <R> ThenStep<T, R> when(IO<R> when) {
      return run(ignore -> when);
    }

    public <R> ThenStep<T, R> when(Producer<R> when) {
      return when(IO.task(when));
    }

    public <R> ThenStep<T, R> error(Throwable error) {
      return when(IO.raiseError(error));
    }
  }

  final class ThenStep<T, R> {

    private final String name;
    private final T given;
    private final Function1<T, IO<R>> when;

    private ThenStep(String name, T given, Function1<T, IO<R>> when) {
      this.name = name;
      this.given = given;
      this.when = when;
    }

    public <E> TestCase<E, R> then(Either<Validator<Result<E>, Throwable>, Validator<Result<E>, R>> then) {
      return new TestCaseImpl<>(name, IO.suspend(() -> when.apply(given)), then);
    }

    public <E> TestCase<E, R> onSuccess(Validator<Result<E>, R> validator) {
      return then(Either.right(validator));
    }

    public <E> TestCase<E, R> onFailure(Validator<Result<E>, Throwable> validator) {
      return then(Either.left(validator));
    }

    public <E> TestCase<E, R> thenCheck(Validator<E, R> validator) {
      return onSuccess(validator.mapError(Result::of));
    }

    public <E> TestCase<E, R> thenError(Validator<E, Throwable> validator) {
      return onFailure(validator.mapError(Result::of));
    }
  }
}

final class TestCaseImpl<E, T> implements SealedTestCase<E, T> {
  
  /**
   * Name of the test case
   */
  private final String name;

  /**
   * It describes the test to run
   */
  private final IO<TestResult<E, T>> test;
  
  /**
   * It will throw {@code IllegalArgumentException} if parameters are null or if name is a empty string
   * 
   * @param name name of the test case
   * @param when operation under test thar returns a value {@code T}
   * @param then Validation to apply to the result generated by operation
   */
  protected TestCaseImpl(String name, IO<T> when, Either<Validator<Result<E>, Throwable>, Validator<Result<E>, T>> then) {
    checkNonNull(when);
    checkNonNull(then);
    this.name = checkNonEmpty(name);
    this.test = when.attempt().map(t -> fold(name, t, then));
  }

  /**
   * Private constructor used mainly for method decorators, like retry or repeat
   * 
   * @param name name of the test case
   * @param test test and validation to be executed
   */
  private TestCaseImpl(String name, IO<TestResult<E, T>> test) {
    this.name = checkNonEmpty(name);
    this.test = checkNonNull(test);
  }

  @Override
  public String name() {
    return name;
  }

  /**
   * It describes the execution of the operation and the validation without executing it yet
   *
   * @return the validation result
   */
  @Override
  public IO<TestResult<E, T>> runIO() {
    return test;
  }

  @Override
  public TestCase<E, T> disable(String reason) {
    return new TestCaseImpl<>(name, IO.pure(disabled(name, reason)));
  }

  @Override
  public TestCase<E, Tuple2<Duration, T>> timed() {
    return new TestCaseImpl<>(name, test.timed().map(tuple -> tuple.applyTo((duration, result) -> result.map(value -> Tuple.of(duration, value)))));
  }

  @Override
  public TestCase<E, T> retryOnFailure(int times) {
    return new TestCaseImpl<>(name, test.flatMap(result -> result.isFailure() ? test.retry(times) : test));
  }

  @Override
  public TestCase<E, T> retryOnError(int times) {
    return new TestCaseImpl<>(name, test.flatMap(result -> result.isError() ? test.retry(times) : test));
  }

  @Override
  public TestCase<E, T> repeat(int times) {
    return new TestCaseImpl<>(name, test.repeat(times));
  }

  private static <E, T> TestResult<E, T> fold(String name, Try<T> result, Either<Validator<Result<E>, Throwable>, Validator<Result<E>, T>> then) {
    return then.fold(

        onFailure -> result.fold(
            error -> onFailure.validate(error).fold(
                r -> failure(name, error, r), t -> success(name, error)),
            value -> error(name, value)),

        onSuccess -> result.fold(
            error -> error(name, error),
            value -> onSuccess.validate(value).fold(
                r -> failure(name, value, r), t -> success(name, value))));
  }
}
