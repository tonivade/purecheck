/*
 * Copyright (c) 2020, Antonio Gabriel Mu√±oz Conejo <antoniogmc at gmail dot com>
 * Distributed under the terms of the MIT License
 */
package com.github.tonivade.purecheck;

import static com.github.tonivade.purecheck.TestResult.disabled;
import static com.github.tonivade.purecheck.TestResult.error;
import static com.github.tonivade.purecheck.TestResult.failure;
import static com.github.tonivade.purecheck.TestResult.success;
import static com.github.tonivade.purefun.Precondition.checkNonEmpty;
import static com.github.tonivade.purefun.Precondition.checkNonNull;

import java.time.Duration;

import com.github.tonivade.purefun.Producer;
import com.github.tonivade.purefun.Tuple;
import com.github.tonivade.purefun.Tuple2;
import com.github.tonivade.purefun.Validator;
import com.github.tonivade.purefun.monad.IO;
import com.github.tonivade.purefun.type.Either;
import com.github.tonivade.purefun.type.Try;
import com.github.tonivade.purefun.type.Validation.Result;

/**
 * It defines a test case, given an operation that eventually returns a value, then
 * it will apply some validations to check if the result is correct.
 * 
 * @author tonivade
 *
 * @param <E> type of error generated
 * @param <T> type under test
 */
public class TestCase<E, T> {
  
  /**
   * Name of the test case
   */
  private final String name;

  /**
   * It describes the test to run
   */
  private final IO<TestResult<E, T>> test;
  
  /**
   * It will throw {@code IllegalArgumentException} if parameters are null or if name is a empty string
   * 
   * @param name name of the test case
   * @param when operation under test thar returns a value {@code T}
   * @param then Validation to apply to the result generated by operation
   */
  protected TestCase(String name, IO<T> when, Either<Validator<Result<E>, Throwable>, Validator<Result<E>, T>> then) {
    checkNonNull(when);
    checkNonNull(then);
    this.name = checkNonEmpty(name);
    this.test = when.attempt().map(t -> fold(name, t, then));
  }

  /**
   * Private constructor used mainly for method decorators, like retry or repeat
   * 
   * @param name name of the test case
   * @param test test and validation to be executed
   */
  private TestCase(String name, IO<TestResult<E, T>> test) {
    this.name = checkNonEmpty(name);
    this.test = checkNonNull(test);
  }

  public String name() {
    return name;
  }

  /**
   * It describes the execution of the operation and the validation without executing it yet
   *
   * @return the validation result
   */
  public IO<TestResult<E, T>> runIO() {
    return test;
  }

  public TestCase<E, T> disable(String reason) {
    return new TestCase<>(name, IO.pure(disabled(name, reason)));
  }

  public TestCase<E, Tuple2<Duration, T>> timed() {
    return new TestCase<>(name, test.timed().map(tuple -> tuple.applyTo((duration, result) -> result.map(value -> Tuple.of(duration, value)))));
  }

  public TestCase<E, T> retryOnFailure(int times) {
    return new TestCase<>(name, test.flatMap(result -> result.isFailure() ? test.retry(times) : test));
  }

  public TestCase<E, T> retryOnError(int times) {
    return new TestCase<>(name, test.flatMap(result -> result.isError() ? test.retry(times) : test));
  }

  public TestCase<E, T> repeat(int times) {
    return new TestCase<>(name, test.repeat(times));
  }

  private static <E, T> TestResult<E, T> fold(String name, Try<T> result, Either<Validator<Result<E>, Throwable>, Validator<Result<E>, T>> then) {
    return then.fold(

        onFailure -> result.fold(
            error -> onFailure.validate(error).fold(
                r -> failure(name, error, r), t -> success(name, error)),
            value -> error(name, value)),

        onSuccess -> result.fold(
            error -> error(name, error),
            value -> onSuccess.validate(value).fold(
                r -> failure(name, value, r), t -> success(name, value))));
  }

  /**
   * It returns a builder like to create a new test case
   * @param <E> type of the result returned by the operation
   * @param <T> type of the error generated by the validator
   * @param name name of the test case
   * @return a new test case
   */
  public static <E, T> WhenStep<E, T> test(String name) {
    return when -> then -> new TestCase<>(name, when, then);
  }
  
  /**
   * It describe the step to define the operation to run by a test case
   *  
   * @param <E> type of the result returned by the operation
   * @param <T> type of the error generated by the validator
   */
  public interface WhenStep<E, T> {

    ThenStep<E, T> when(IO<T> operation);

    default ThenStep<E, T> when(Producer<T> operation) {
      return when(IO.task(operation));
    }

    default ThenStep<E, T> when(T value) {
      return when(IO.pure(value));
    }

    default ThenStep<E, T> when(Throwable error) {
      return when(IO.<T>raiseError(error));
    }
  }
  
  /**
   * It describe the step to define the validation to check by a test case
   * 
   * @param <E> type of the result returned by the operation
   * @param <T> type of the error generated by the validator
   */
  public interface ThenStep<E, T> {
    
    TestCase<E, T> then(Either<Validator<Result<E>, Throwable>, Validator<Result<E>, T>> validator);

    default TestCase<E, T> onSuccess(Validator<Result<E>, T> validator) {
      return then(Either.right(validator));
    }

    default TestCase<E, T> onFailure(Validator<Result<E>, Throwable> validator) {
      return then(Either.left(validator));
    }
    
    default TestCase<E, T> thenCheck(Validator<E, T> validator) {
      return onSuccess(validator.mapError(Result::of));
    }
    
    default TestCase<E, T> thenError(Validator<E, Throwable> validator) {
      return onFailure(validator.mapError(Result::of));
    }
  }
}
