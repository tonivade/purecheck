package com.github.tonivade.purecheck;

import static com.github.tonivade.purefun.Precondition.checkNonEmpty;
import static com.github.tonivade.purefun.Precondition.checkNonNull;

import com.github.tonivade.purefun.Validator;
import com.github.tonivade.purefun.concurrent.Par;
import com.github.tonivade.purefun.monad.IO;
import com.github.tonivade.purefun.type.Validation.Result;

/**
 * It defines a test case, given an operation that eventually returns a value, then
 * it will apply some validations to check if the result is correct.
 * 
 * @author tonivade
 *
 * @param <E> type of error generated
 * @param <T> type under test
 */
public class TestCase<E, T> {
  
  /**
   * Name of the test case
   */
  private final String name;

  /**
   * Operation under test that returns a value {@code T}
   */
  private final IO<T> when;
  
  /**
   * Validation to apply to the result generated by operation
   */
  private final Validator<Result<E>, T> then;

  /**
   * It will throw {@code NullPointerException} if parameters are null
   * 
   * @param when
   * @param then
   */
  private TestCase(String name, IO<T> when, Validator<Result<E>, T> then) {
    this.name = checkNonEmpty(name);
    this.when = checkNonNull(when);
    this.then = checkNonNull(then);
  }
  
  /**
   * It runs the operation and applies the validation
   * 
   * @return the validation result
   */
  public TestResult<E, T> unsafeRun() {
    return new TestResult<>(name, then.validate(when.unsafeRunSync()));
  }
  
  public Par<TestResult<E, T>> asyncRun() {
    return Par.task(this::unsafeRun);
  }
  
  public static <E, T> TestCaseBuilder<E, T> test() {
    return name -> when -> then -> new TestCase<>(name, when, then);
  }
  
  public interface NameStep<E, T> {
    WhenStep<E, T> name(String name);
  }
  
  public interface WhenStep<E, T> {
    ThenStep<E, T> when(IO<T> operation);
  }
  
  public interface ThenStep<E, T> {
    TestCase<E, T> then(Validator<Result<E>, T> validator);
  }
  
  public interface TestCaseBuilder<E, T> extends NameStep<E, T> { }
}
