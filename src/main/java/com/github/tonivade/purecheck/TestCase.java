package com.github.tonivade.purecheck;

import static com.github.tonivade.purefun.Precondition.checkNonEmpty;
import static com.github.tonivade.purefun.Precondition.checkNonNull;

import com.github.tonivade.purefun.Validator;
import com.github.tonivade.purefun.concurrent.Par;
import com.github.tonivade.purefun.monad.IO;
import com.github.tonivade.purefun.type.Validation.Result;

/**
 * It defines a test case, given an operation that eventually returns a value, then
 * it will apply some validations to check if the result is correct.
 * 
 * @author tonivade
 *
 * @param <E> type of error generated
 * @param <T> type under test
 */
public class TestCase<E, T> {
  
  /**
   * Name of the test case
   */
  private final String name;

  /**
   * Operation under test that returns a value {@code T}
   */
  private final IO<T> when;
  
  /**
   * Validation to apply to the result generated by operation
   */
  private final Validator<Result<E>, T> then;

  /**
   * It will throw {@code IllegalArgumentException} if parameters are null or if name is a empty string
   * 
   * @param name
   * @param when
   * @param then
   */
  private TestCase(String name, IO<T> when, Validator<Result<E>, T> then) {
    this.name = checkNonEmpty(name);
    this.when = checkNonNull(when);
    this.then = checkNonNull(then);
  }
  
  /**
   * It runs the operation and applies the validation
   * 
   * @return the validation result
   */
  public TestResult<E, T> unsafeRun() {
    T value = when.unsafeRunSync();
    return new TestResult<>(name, value, then.validate(value));
  }
  
  /**
   * It returns a Par to run the test in another thread
   * 
   * @return the validation result
   */
  public Par<TestResult<E, T>> asyncRun() {
    return Par.task(this::unsafeRun);
  }
  
  /**
   * It returns a builder like to create a new test case
   * @param <E> type of the result returned by the operation
   * @param <T> type of the error generated by the validator
   * @param name name of the test case
   * @return a new test case
   */
  public static <E, T> WhenStep<E, T> test(String name) {
    return when -> then -> new TestCase<>(name, when, then);
  }
  
  public static <E, T> TestFactory<E, T> factory() {
    return new TestFactory<E, T>() { };
  }
  
  /**
   * It describe the step to define the operation to run by a test case
   *  
   * @param <E> type of the result returned by the operation
   * @param <T> type of the error generated by the validator
   */
  public interface WhenStep<E, T> {

    /**
     * 
     * @param operation
     * @return
     */
    ThenStep<E, T> when(IO<T> operation);
  }
  
  /**
   * It describe the step to define the validation to check by a test case
   * 
   * @param <E> type of the result returned by the operation
   * @param <T> type of the error generated by the validator
   */
  public interface ThenStep<E, T> {
    
    /**
     * 
     * @param validator
     * @return
     */
    TestCase<E, T> then(Validator<Result<E>, T> validator);
  }
}
