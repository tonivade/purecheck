/*
 * Copyright (c) 2020-2023, Antonio Gabriel Mu√±oz Conejo <antoniogmc at gmail dot com>
 * Distributed under the terms of the MIT License
 */
package com.github.tonivade.purecheck;

import static com.github.tonivade.purefun.core.Precondition.checkNonEmpty;
import static com.github.tonivade.purefun.core.Precondition.checkNonNull;

import java.util.concurrent.Executor;

import com.github.tonivade.purefun.Kind;
import com.github.tonivade.purefun.concurrent.Future;
import com.github.tonivade.purefun.data.NonEmptyList;
import com.github.tonivade.purefun.data.Sequence;
import com.github.tonivade.purefun.data.SequenceOf;
import com.github.tonivade.purefun.typeclasses.Instances;
import com.github.tonivade.purefun.typeclasses.Parallel;

/**
 * <p>It defines a test suite that is composed by a non-empty collection of test cases
 *
 * <p>It allows to run the tests serialized one by one with {@code #run()} of in parallel with {@code #parRun(Executor)}
 *
 * @author tonivade
 *
 * @param <F> type of the kind
 * @param <E> type of the error
 */
public abstract class TestSuite<F, E> {

  private final Parallel<F, F> parallel;
  private final String name;
  private final Sequence<TestCase<F, E, ?, ?>> tests;

  /**
   * It will throw {@code NullPointerException} if the tests is null
   *
   * @param parallel parallel instance for type F
   * @param name name of the suite
   * @param tests list of tests
   */
  protected TestSuite(Parallel<F, F> parallel, String name, NonEmptyList<TestCase<F, E, ?, ?>> tests) {
    this.parallel = checkNonNull(parallel);
    this.name = checkNonEmpty(name);
    this.tests = checkNonNull(tests);
  }

  /**
   * It runs the suite in the given effect of the test and creates a test results
   *
   * @return the result of the suite
   */
  public Kind<F, Report<E>> runK() {
    var sequence = Instances.<Sequence<?>>traverse().sequence(parallel.monad(), tests.map(TestCase::run));

    Kind<F, Sequence<TestResult<E, ?, ?>>> results = parallel.monad().map(sequence, SequenceOf::narrowK);

    return parallel.monad().map(results, xs -> new Report<>(name, xs));

  }

  public Kind<F, Report<E>> runParK() {
    var sequence = parallel.parSequence(Instances.traverse(), tests.map(TestCase::run));

    Kind<F, Sequence<TestResult<E, ?, ?>>> results = parallel.monad().map(sequence, SequenceOf::narrowK);

    return parallel.monad().map(results, xs -> new Report<>(name, xs));
  }

  /**
   * It runs the suite one by one
   *
   * @return the result of the suite
   */
  public abstract Report<E> run();

  /**
   * It runs the suite in parallel using the default executor
   *
   * @return a future with the result of the suite
   */
  public Future<Report<E>> parRun() {
    return parRun(Future.DEFAULT_EXECUTOR);
  }

  /**
   * It runs the suite in parallel using the given {@code Executor}
   *
   * @param executor executor on which the suite is going to be executed
   * @return a future with the result of the suite
   */
  public abstract Future<Report<E>> parRun(Executor executor);

  /**
   * It describes the report generated by a test suite.
   *
   * @author tonivade
   *
   * @param <E> type of the error generated by the tests
   */
  public static class Report<E> {

    private final String name;
    private final Sequence<TestResult<E, ?, ?>> results;

    public Report(String name, Sequence<TestResult<E, ?, ?>> results) {
      this.name = checkNonEmpty(name);
      this.results = checkNonNull(results);
    }

    public void assertion() {
      results.forEach(TestResult::assertion);
    }

    @Override
    public String toString() {
      return results.join("\n- ", "## " + name + "\n\n- ", "\n");
    }
  }
}
